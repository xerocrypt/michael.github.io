<html>
    <head>
        <title>Linux Process Analysis</title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>

    <body>

        <div id="header">
            <h1>Linux Process Analysis</h1>
        </div>

        <div id="article">
            When it comes to detecting, capturing and analysing malware, the hard drive isn’t so important unless we’re establishing a timeline for how it got there. The kernel and anything that’s running on a system lives in memory, plus it’s where the unencrypted/unobfuscated malware payloads are. System memory is also the one place we’re likely to find cryptographic keys, if we’re really desperate and know roughly where to look.</br></br>

            Where to begin? As with Windows processes, the processes in UNIX-based systems are contiguous data structures, containers created by the kernel for running programs. They contain everything a program might need, including an image of the executable, links to external .so objects (roughly analogous to Windows DLLs), variables, runtime data, etc. A process has a definite logical structure, although that’s not immediately apparent outside textbooks.</br>
            The most lucid representations I could find were by Gustavo Duarte and a Lawrence Livermore National Laboratory tutorial, which I’ve merged for clarity:</br></br>

            <img src="images/process-structure.gif"></br></br>

            Of course, the stack is also in there, where variables passed to whatever functions and return addresses are found. According to the LLNL tutorial, threads are written to and from the stack.
        </div>

        <div id="article">
            <h2>procfs</h2>
            This is important, because system monitoring tools will almost always get their information from something called <i>procfs</i>. Practically everything in a UNIX system is represented by a file – sometimes files are created as interfaces or pointers to something physical. From the user perspective procfs is the <i>/proc</i> directory, which contains a number of virtual directories and files (existing entirely in system memory) representing low-level stuff such as processes, memory allocations and hardware components. Most the <i>procfs</i> files can be accessed directly.</br></br>

            The common way to find what’s running on a machine is the ‘<i>top</i>‘ command, but it’s only going to show processes that are active or being awakened, and not suspended/dormant processes. This is where ‘<i>ps</i>‘ command becomes a handy alternative:</br>
            <code>#ps -el</code></br>
‍
            Lists all processes resident in memory:</br>
            <code>ps-el</code></br>

            But, as Prof. Andrew Blyth would say, ‘user-space is a lie’, meaning the user-space programs can only report what kernel-space tells it. The implication is that a kernel-mode rootkit can hide information about processes and network activity from user-space, and Android OS is a total bitch for doing precisely that (unless the device is rooted).</br>
            With typical Linux desktops and servers, there are various ways around this. One of them is using unhide to catch discrepencies between CPU, memory usage and what <i>/bin</i> (or <i>/sbin</i>) executables report, and another method compares system calls with a fixed system call map.</br></br>

            Back to the list of processes: Having got the PIDs for active and dormant processes, and having found which programs they might belong to, a considerable amount about a given process can be learned by reading from <i>/proc</i>.</br>
            The directories of interest are listed to the left, when using the ‘<i>ls</i>‘ command. The directory names are the PIDs for processes resident in memory, and each contains a number of virtual files.</br></br>

            To get a rough picture of what the process contains, pmap is worth trying:</br>
            <code>#pmap 2586</code></br>

            This appears to do pretty much the same thing as:</br>
            <code>#cat maps</code></br>

            Of course, the contents can be dumped to a text file with</br>
            <code>#cat maps >> dumpfile.txt</code></br>

            Two values that might be important, which tell us the start and end addresses for the memory allocated to a process:
            <ul>
                <li>vm_start – First address within virtual memory.</li>
                <li>vm_end – First address outside virtual memory.</li>
            </ul>

            Other files of interest include:
            <ul>
                <li>/proc/[PID]/exe: Contains symbolic links to the executable binary file.</li>
                <li>/proc/[PID]/limits: Resource limits assigned to the process.</li>
                <li>/proc/[PID]/maps: A memory map of the process.</li>
                <li>/proc/[PID]/sched: Thread scheduling stats for the threads generated by the process.</li>
            </ul>
        </div>

        <div id="article">
            <h2>A couple of other tools</h2>
            Another useful utility is <i>pstree</i>, which shows whether a PID has any parent or child processes. The strace utility will output the system calls made by a process. For example, if Firefox has a PID of 2990:
            <code>#strace -p 2990</code></br>
        </div>

        <div id="article">
            <h2>Viewing process memory and the stack</h2>
            It took some research to find something that enabled me to view the raw contents of a process’ memory space. Eventually I decided on scanmem, a little utility that lists memory sections/segments and dumps them to a file for later analysis.</br>
            The first thing to do is point scanmem at the right PID (Firefox has a PID of 2990 here):
            <code>0> pid 2990</code></br>
            
            The ‘<i>lregions</i>‘ command will give a list of sections/segments found, along with the stack address and size. For example, it could show the address as 0xbfba6000, and a length of 180224 bytes. Dumping this should produce an 180KB file, basically. Remember, the stack size of a relatively dynamic program could change while being dumped, so this only gives a snapshot:</br>
            <code>0> dump 0xbfba6000 180224 /home/michael/scanmem-stack-dump</code></br>

            The dump file is quite readable in a hex editor, but the Bokken reverse engineering tool gives better results (when it doesn’t crash). Notice that bit where it says ‘<i>Write a comment</i>‘ at address 0x8a30: I was logged into FaceBook, and the ‘Comment’/’Like’ input fields got pushed onto the stack when I switched to another browser tab.</br></br>

            Further up the stack, at 0x28ce4, some global variables or parameters are found, including the user name, the hostname, the PID of a crypto provider, session cookies, important filesystem locations, etc. I honestly didn’t expect to find that in the stack, but there it is.
        </div>

        <div id="article">
            <h2>The Kernel</h2>
            More than the huge chunk of monolithic code, I’m referring to kernel-space, which is the physical memory allocated to the kernel. Generally off limits to users, interaction between user and kernel space is through system calls. When the user double-clicks on that Firefox icon or runs a shell command, the kernel allocates a block of memory for the process, responds to system calls from that process, and manages the execution of that process’ threads on the processor. The kernel also has an interface in <i>procfs</i>.</br></br>

            It’s possible to use ‘<i>cat kcore</i>‘, but that would screw up the terminal session after pressing <i>Ctrl+C</i>, probably because it’s overflowed a buffer related to stdout(). A better way is to use:
            <code>#strings -n 10 kcore</code></br>

            Some users with Clam AV installed might be surprised when the output produces a list of (Windows) Trojans. Relax – they don’t actually exist. What I think is happening is bytes are continually passing through system memory, and just like that monkeys with a typewriter thing, <i>kcore</i> will inevitably dump erroneous byte patterns associated with known malware. For this reason, anti-malware programs should never scan <i>kcore</i>.
        </div>

        <div id="article">
            <h2>References</h2>
        </div>

        <div id="footer">Michael, April 2017</div>
    </body>
</html>
