<html>
    <head>
        <title>Anyone Can Program</title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>

    <body>

        <div id="header">
            <h1>Anyone Can Learn to Program</h1>
        </div>
		
		<div id="article">
			There are many points I'd like to add to <a href="https://uwnthesis.wordpress.com/2017/07/15/can-anyone-become-a-programmer/">UWNThesis' post</a> 'Can anyone become a programmer?' and the <a href="http://www.eis.mdx.ac.uk/research/PhDArea/saeed/">study papers</a> linked to it. My answer is that yes, anyone can become a programmer, but that's putting it simply.</br></br>

			It just so happens that I attended a talk many years ago, by a computer scientist from Cardiff University, <a href="https://langbein.org">Dr. Frank Langbein</a>, who argued that anyone can and <i>should</i> learn to program. It's very important to note that Dr. Langbein was not arguing that people should 'learn to code' for the sake of being able to 'code' - the usefulness of doing that in isolation is pretty questionable.</br>
			No, his argument was that users have more control of their computers, more freedom, without 'user-friendly' interfaces, and therefore everyone should learn how to use the command line. I've probably made a post on his talk at some point, as it covers some interesting observations on how companies like FaceBook and Twitter can subtly manipulate their users simply by shaping the design of their interfaces. 
			Eventually I was in the habit of doing everything in the Linux command line - browsing the Internet, accessing emails, modifying spreadsheets, configuring and administrating servers, drafting research papers and generating them in the same format as you'd see in a scientific journal, etc. etc.</br></br>

			How is this related to whether one could learn programming, you might ask? Well, I'm firmly convinced that, given enough time, anyone can install Linux or FreeBSD on an old computer, start experimenting with the command line and become reasonably adept at it. And with some familiarity with the command line syntax, putting together a BASH script is a relatively trivial task. From there, one could learn Python, and perhaps move onto a more 'serious' language.</br>
			I'm convinced that everyone has the innate ability to do this. The real problem is that actual software engineering or development as a profession requires a much broader skillset. As a bare minimum, you'd need to learn Agile development principles, SOLID design patterns, version control, unit testing, continuous integration, configuration management and some variant of SQL. And not just that. As with any profession, your expertise needs to be current, and that often means learning how to work with new languages and frameworks. It takes several years' hard work, not some 'bootcamp'/'dojo', to make it stick.</br></br>

			What does this mean in relation to UWNthesis' post and the linked study papers discussing the success/failure/dropout rates in undergraduate programming courses? The <a href="http://www.eis.mdx.ac.uk/research/PhDArea/saeed/paper1.pdf">2006 paper's</a> abstract claims that '<i>programming teaching is useless for those who are bound to fail and pointless for those who are certain to succeed.</i>'</br>
			Aside from it being unfair and a serious misjudgement to write off anyone before they've grasped the technical theory and structured methods of reasoning - which is what's supposed to be learned at university - both assertions are correct, but for a very different reason. The typical  programming course (at least the ones I've encountered) follows a standard syllabus that concentrates on the syntax of an arbitrarily-chosen language, using an arbitrarily-chosen IDE, completing arbitrary tasks that aren't reflective of  real-world problems. <br></br>

			My experience tells me that informal methods of learning are more effective: Despite most decent hacking tools being command-line utilities, it was actually possible (but not common) to graduate in computer security without having done any programming beyond a first year module in Visual Basic, yet most the highly-motivated undergraduates were successfully teaching themselves BASH scripting and Python during their <i>final</i> year.</br></br>

			Nacko, commenting on Ars Technica, put is much better than I could:</br>
			<code>
			'Saying a person "can't program" is like saying he can't build a house. There is a lot of foundation skill and knowledge that goes into being able to successfully build a house. I would think the only way forward is to identify a more specific deficiency than "unable to build a house" and correct that with appropriate study and training. I suspect that applies to programming as well, and that most people can at least achieve competency'.
			</code>
		</div>

		<div id="article">
			<h2>A Suggested Approach</h2>
			If the formal methods of teaching have such a high failure rate, then the approach of telling everyone they should 'learn to code' before throwing yet more textbook excercises at them obviously isn't working.  If I'm right, anyone could learn a programming language, but 
			there's a huge difference between the kind of programming taught in courses and the kind of programming done in commercial software development.</br></br>

			Doing this with the right language and IDE are also important. Python is good for beginners, because a brief introduction to the language and syntax is all that's needed before focussing entirely on how to make Python scripts work with third-party modules. A course, could for example, take the form of an eight-week project to build an interface to a MySQL database, during which students could gain an understanding of what the code and modules are doing in the background. You'd also find that syntax and the minutae of the language actually matters little compared to the problem-solving.</br>
			The right IDE is important, because you don't want something advanced that presents a mess to novices. I recommend a lightweight, clean IDE that has just enough features to present things as abstractions. Geany or Notepad++ is a good choice, with the Python interpreter being used separately.</br></br>

			Many of the concepts learned using Python could then be carried over into a secondary course with Java or C#, which might introduce real-world software design and engineering concepts - the SOLID design principles being chief among them.
		</div>
		
		<div id="article">
			<h2>References</h2>
			STACK EXCHANGE. 2012. Technology Lab: Is it true that “not everyone can be a programmer”?. <i>Ars Technica</i>. [WWW]. <a href="https://arstechnica.com/information-technology/2012/09/is-it-true-that-not-everyone-can-be-a-programmer/">https://arstechnica.com/information-technology/2012/09/is-it-true-that-not-everyone-can-be-a-programmer/</a>. (19th July 2017).</br></br>
			
			DEHNADI, S. BORNAT, R. 2006. The camel has two humps. <i>School of Computing, Middlesex University, UK</i>. [PDF]. <a href="http://www.eis.mdx.ac.uk/research/PhDArea/saeed/paper1.pdf">http://www.eis.mdx.ac.uk/research/PhDArea/saeed/paper1.pdf</a>. (19th July 2017).</br></br>
		</div>

        <div id="footer">Michael, July 2017</div>
    </body>
</html>
