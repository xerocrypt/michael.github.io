<html>
    <head>
        <title>SOLID Principles of Software Design</title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>

    <body>

        <h1>SOLID Principles of Software Design</h1>

        <img src="images/SOLID-points-diagram.png" width="500" height="400"></br>

        <div id="article">
            <h2>Single Responsibility Principle</h2>
            Robert C. Martin explains this principle with the statement: 'A class should have only one reason to change.'. What it actually means is that each module or function should have only one specific responsibility, and it should be encapsulated.</br>
            Anyone who's done some object-oriented programming should be familiar with this concept. Functions are the building blocks of software, and we use them even when we're not aware of it.
            An ideal program is designed so that every function or method does something very specific, and we avoid creating a function that does multiple things. This is one of the ways to make code more readable.
            </br></br>
            To give a real-world example:</br></br>
            <img src="images/single-responsibility-example.png"></br></br>

            As you can see, it simply returns the date and time to the calling function. It doesn't print the time or do anything except return it.</br></br>
 
            And another function that simply sets the username and password properties:</br></br>

            <img src="images/single-responsibility-example-2.png"></br></br>
            You'd also expect there to be fewer compile errors, and the code is more easily unit tested.
        </br></br>
    </div>

    <div id="article">
        <h2>Open/Closed Principle</h2>
        Modules 'should be open for extension but closed for modification', as the Wikipedia entry states. The following rules are also stated:</br>
        <ul>
            <li>A module is considered open if it can be extended.</li>
            <li>A module is closed if it's available to use by other modules, and has a well-defined and stable description.</li>
        </ul>

        Basically this expands on the principle of single responsibility, the two being a guide to the proper design of a module.
        </br></br>
    </div>

    <div id="article">
        <h2>Liskov Substitution Principle</h2>
        This principle is essentially all about base classes and derived classes. A way to make code reusable, so the programmer isn't creating the same function multiple times. Instead, the programmer uses instances of a base class where needed.</br></br>
 
        '<quote>if S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program</quote>'.</br></br>
 
        Another general rule is derived classes shouldn't throw exceptions if their base classes don't.
        </br></br>
    </div>

    <div id="article">
    <h2>Interface Segregation Principles</h2>
    Apparently 'many client-specific interfaces are better than one general-purpose interface'. I think it refers to having multiple entry points, each for something specific. If the other principles are followed, it should be more straightforward to trace the code for each entry point and modify it as required.
    The other idea here is that clients shouldn't have dependencies on components it doesn't use.</br></br>
 
    This principle is applied by breaking down large interfaces into smaller specific ones.
    Say, for example, we have a large interface. A problem with that interface could break the interoperability with clients that don't use the affected part of that interface. Conversely, if the interface was broken down into smaller interfaces, the problem would be isolated and would have more limited effects on the clients.</br></br>
 
    This principle also creates layers of abstraction to reduce dependencies. You could design the software to have interfaces and implementation classes - interfaces describe the intention, and implementation classes perform the intended task.</br>
    If this principle is followed, a developer shouldn't need to be concerned with the details of how a feature works, but only with what the feature does. The developer should be able to make use of the function/component purely by its interface. The implementation could also be changed without breaking the software.</br>
    This information hiding is referred to as 'encapsulation'.
    </br></br>
</div>

<div id="article">
    <h2>Dependency Inversion Principle</h2>
    A program should depend upon abstractions instead of depending on concretions. In other words, the program should be dependent on the higher-level stuff instead of the low-level components. It's easy to see why.
    Everything should be determined on what the abstractions specify the program should do.</br></br>
 
    In practice this refers to the decoupling or loose coupling of software modules. This is referred to as 'dependency inversion' because it inverts the way people think about object-oriented programming.
    Traditionally the higher-level functioning of a program depend on the lower level components that perform tasks. A defect in the lower-level could therefore break the high-level functions. Plus it limits the potential for re-using modules.</br>
    One way to solve this is to add a mediation layer (or interface) between the high and low-level components.
    </br></br>
</div>

</body>
</html>
