<html>
    <head>
        <title>SOLID Principles of Software Design</title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>

    <body>

        <div id="header">
            <h1>SOLID Principles of Software Design</h1>
        </div>

        <div id="article">
            <img src="images/SOLID-points-diagram.png" width="500" height="400"></br>
        </div>

        <div id="article">
            <h2>Single Responsibility Principle</h2>
            Robert C. Martin explains this principle with the statement: 'A class should have only one reason to change.'. What it actually means is that each module or function should have only one specific responsibility. We should avoid creating a module that does more than one specific thing. A <i>class</i> should perform one <i>type</i> of function  only. For example, a class shouldn't perform one function and log errors - a separate class, for logging, should be used for the latter.
            </br></br>

            To give a real-world example:</br></br>
            <img src="images/single-responsibility-example.png"></br></br>

            As you can see, it simply returns the date and time to the calling function. It doesn't print the time or do anything except return it.</br>
            And another function that simply sets the username and password properties:</br></br>

            <img src="images/single-responsibility-example-2.png"></br></br>
            You'd also expect there to be fewer compile errors, and the code is more easily unit tested.
            </br></br>
        </div>

        <div id="article">
            <h2>Open/Closed Principle</h2>
            Basically means it should be possible to modify or extend the behaviour of a module without changing its source code. If a module is 'open' it could be extended to accommodate additional data structures. If the module is 'closed' it has a stable and defined behaviour.
            Modules 'should be open for extension but closed for modification', as the Wikipedia entry states. The following rules are also stated:</br>
            <ul>
                <li>A module is considered open if it can be extended.</li>
                <li>A module is closed if it's available to use by other modules, and has a well-defined and stable description.</li>
            </ul>

            Basically this expands on the principle of single responsibility, the two being a guide to the proper design of a module. It should be possible to create multiple instances of a 'closed' module as an abstract base class.
            </br></br>
        </div>

        <div id="article">
            <h2>Liskov Substitution Principle</h2>
            The official definition is '<quote>if S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program</quote>'</br>
            All this means is a derived class should function exactly as if its base class was used. The derived class implements the base class, thereby making the code re-usable as needed. This enables multiple instances of a class to be extended and used without duplicating its code.
            </br></br>
        </div>

        <div id="article">
            <h2>Interface Segregation Principles</h2>
            Apparently 'many client-specific interfaces are better than one general-purpose interface'. I think it refers to having multiple entry points, each for something specific. If the other principles are followed, it should be more straightforward to trace the code for each entry point and modify it as required.
            The other idea here is that clients shouldn't have dependencies on components it doesn't use.</br></br>

            This principle is applied by breaking down large interfaces into smaller specific ones.
            Say, for example, we have a large interface. A problem with that interface could break the interoperability with clients that don't use the affected part of that interface. Conversely, if the interface was broken down into smaller interfaces, the problem would be isolated and would have more limited effects on the clients.</br></br>

            This principle also creates layers of abstraction to reduce dependencies. You could design the software to have interfaces and implementation classes - interfaces describe the intention, and implementation classes perform the intended task.</br>
            If this principle is followed, a developer shouldn't need to be concerned with the details of how a feature works, but only with what the feature does. The developer should be able to make use of the function/component purely by its interface. The implementation could also be changed without breaking the software.</br>
            This information hiding is referred to as 'encapsulation'.
            </br></br>
        </div>

        <div id="article">
            <h2>Dependency Inversion Principle</h2>
            A program should depend upon abstractions instead of depending on concretions. In other words, the program should be dependent on the higher-level stuff instead of the low-level components. It's easy to see why.
            Everything should be determined on what the abstractions specify the program should do.</br></br>

            In practice this refers to the decoupling or loose coupling of software modules. This is referred to as 'dependency inversion' because it inverts the way people think about object-oriented programming.
            Traditionally the higher-level functioning of a program depend on the lower level components that perform tasks. A defect in the lower-level could therefore break the high-level functions. Plus it limits the potential for re-using modules.</br>
            One way to solve this is to add a mediation layer (or interface) between the high and low-level components.</br></br>

            <button onclick="window.location.href='dependency-inversion.html'">Main Article...</button>

        </div>

    </body>
</html>
