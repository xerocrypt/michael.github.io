<html>
    <head>
        <title>SOLID Principles of Software Design</title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>

    <body>

<h1>SOLID Principles of Software Design</h1>


<div id="article">
    <h2>Single Responsibility Principle</h2>
Robert C. Martin explains this principle with the statement: 'A class should have only one reason to change.'. What it actually means is that each module or function should have only one specific responsibility, and it should be encapsulated.
</br></br>
</div>

<div id="article">
<h2>Open/Closed Principle</h2>


In object-oriented programming, the open/closed principle states "software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification";[1] that is, such an entity can allow its behaviour to be extended without modifying its source code.

The name open/closed principle has been used in two ways. Both ways use inheritance to resolve the apparent dilemma, but the goals, techniques, and results are different.

</br></br>
</div>

<div id="article">
<h2>Liskov Substitution Principle</h2>
Seems to have something to do with base classes and inheritance.

</br></br>
</div>

<div id="article">
<h2>Interface Segregation Principles</h2>



The interface-segregation principle (ISP) states that no client should be forced to depend on methods it does not use.[1] ISP splits interfaces that are very large into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them. Such shrunken interfaces are also called role interfaces.[2] ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy. ISP is one of the five SOLID principles of object-oriented design, similar to the High Cohesion Principle of GRASP.[3]

</br></br>
</div>

<div id="article">
<h2>Dependency Inversion Principle</h2>


In object-oriented design, the dependency inversion principle refers to a specific form of decoupling software modules. When following this principle, the conventional dependency relationships established from high-level, policy-setting modules to low-level, dependency modules are reversed, thus rendering high-level modules independent of the low-level module implementation details. The principle states:[1]

A. High-level modules should not depend on low-level modules. Both should depend on abstractions.
B. Abstractions should not depend on details. Details should depend on abstractions.
This design principle inverts the way some people may think about object-oriented programming, dictating that both high- and low-level objects must depend on the same abstraction.[2]

The idea of the writing in two points of this principle is that when designing the interaction between a high-level module and a low-level one, the interaction should be thought as an abstract interaction between them. This not only has implications on the design of the high-level module, but also on the low-level one: the low-level one should be designed with the interaction in mind and it may be necessary to change its usage interface.

In many cases, thinking the interaction in itself as an abstract concept allows the coupling of the components to be reduced without introducing additional coding patterns, allowing only a lighter and less implementation dependent interaction schema.

When the discovered abstract interaction schema(s) between two modules is/are generic and generalization makes sense, this design principle also leads to the following dependency inversion coding pattern.

</br></br>
</div>

    </body>
</html>
